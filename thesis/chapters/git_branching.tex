\section{Введение в Learn Git Branching}\label{sec:learn-git-branching-intro}
Learn Git Branching — это интерактивный веб-тренажер для изучения Git.
Он визуализирует структуру коммитов и веток, что сильно упрощает понимание команд.
На \refFigure{git-branching/basics/c1t1.png} представлен интерфейс тренажера в начале первого задания.

\imageWithCaption{git-branching/basics/c1t1.png}{Главный экран Learn Git Branching}
\label{fig:lgb_main_screen}


\section{Основные уровни: ветвление и слияние}\label{sec:lgb-basic-branching-and-merging}
Начальные уровни посвящены базовым командам, таким как создание коммитов, ветвление и слияние.

\subsection{Команды \texttt{git commit} и \texttt{git branch}}\label{subsec:lgb-commit-and-branch}
Данный раздел посвящен анализу фундаментальных операций в системе контроля версий Git: созданию коммитов и управлению ветвями.
Эти концепции являются основополагающими для эффективной разработки программного обеспечения и совместной работы над проектами.
Коммиты представляют собой дискретные единицы сохранения изменений в истории проекта, тогда как ветви обеспечивают механизмы параллельной разработки различных функциональностей или исправлений ошибок.

\subsubsection{Создание Коммитов: Команда \texttt{git commit}}\label{subsubsec:git-commit}
Изображение \refFigure{git-branching/basics/c1t1.png} иллюстрирует процесс создания коммитов, являющихся ключевыми точками фиксации состояния проекта.

\imageWithCaption{git-branching/basics/c1t1.png}{Процесс создания коммитов в Git}
\label{fig:lgb_commit}

На левой панели изображения представлена последовательность команд, выполненных в командной строке:
\begin{itemize}
    \item \texttt{level intro1}, \texttt{hint}, \texttt{delay 2000}, \texttt{show goal}: Данные команды являются служебными, предназначенными для управления обучающей средой и предоставления инструкций пользователю.
    Их функционал не относится непосредственно к системе контроля версий Git.
    \item \texttt{git commit -m "c2"}: Эта команда инициирует создание нового коммита.
    \begin{itemize}
        \item \texttt{git commit}: Основная команда для фиксации текущего состояния индекса (staging area) в репозитории.
        Коммит формирует новый узел в графе истории проекта.
        \item \texttt{-m "c2"}: Флаг \texttt{-m} (от "message") позволяет прикрепить к коммиту краткое описательное сообщение.
        В данном случае, сообщение "c2" (предположительно, сокращение от "commit 2") служит для идентификации внесенных изменений.
    \end{itemize}
    На правой панели графического представления истории Git наблюдается появление нового коммита \texttt{C2}, который является непосредственным потомком коммита \texttt{C1}.
    \item \texttt{git commit -m "c3"}: Аналогично предыдущей, данная команда создает второй коммит с сообщением "c3".
    На визуализации графа истории, коммит \texttt{C3} располагается после \texttt{C2}.
    Красный указатель \texttt{main*} перемещается на \texttt{C3}, что свидетельствует о том, что текущая активная ветвь, по умолчанию именуемая \texttt{main}, теперь указывает на данный вновь созданный коммит.
    Таким образом, команды демонстрируют последовательное добавление двух новых "снимков" состояния проекта в его историю.
\end{itemize}
В результате, команда \texttt{git commit -m "ваше\_сообщение"} является стандартом для сохранения осмысленных и инкрементальных изменений в истории репозитория Git.

\subsubsection{Управление Ветвями: Команды \texttt{git checkout -b} и \texttt{git merge}}\label{subsubsec:git-branch}
Изображение \refFigure{git-branching/basics/c1t3.png} демонстрирует более продвинутые операции Git, связанные с ветвлением и слиянием, которые критически важны для организации параллельной разработки.

\imageWithCaption{git-branching/basics/c1t3.png}{Создание и слияние веток в Git}
\label{fig:lgb_branch}

Последовательность команд, выполненных для иллюстрации данного процесса, включает:
\begin{itemize}
    \item \texttt{clear}: Данная команда служит для очистки консоли, обеспечивая наглядность последующих операций.
    \item \texttt{git checkout -b bugFix}: Эта команда выполняет две ключевые операции:
    \begin{itemize}
        \item \texttt{git checkout}: Используется для переключения рабочего указателя (HEAD) на другую ветвь или коммит.
        \item \texttt{-b bugFix}: Флаг \texttt{-b} указывает на необходимость создания новой ветви с именем \texttt{bugFix} и немедленного переключения на нее.
    \end{itemize}
    На правой панели визуализации графа истории показано создание новой ветви \texttt{bugFix}, которая изначально указывает на тот же коммит, что и ветвь \texttt{main} (предположительно, \texttt{C1} в контексте исходного состояния).
    Активная ветвь обозначается как \texttt{bugFix*}, указывая на текущее местоположение указателя HEAD\@.
    \item \texttt{git commit -m "c2"}: Находясь в ветви \texttt{bugFix}, выполняется создание нового коммита с сообщением "c2".
    Данный коммит (\texttt{C2} на схеме) становится новым "вершинным" коммитом для ветви \texttt{bugFix}, в то время как ветвь \texttt{main} остается на своем предыдущем коммите (на схеме \texttt{C1}).
    \item \texttt{git checkout main}: Команда для переключения обратно на ветвь \texttt{main}.
    Красный указатель \texttt{main*} на визуализации графа перемещается, указывая на коммит \texttt{C1}.
    \item \texttt{git commit -m c3}: В ветви \texttt{main} создается новый коммит с сообщением "c3".
    На схеме это коммит \texttt{C3}, который является потомком \texttt{C1} и становится "вершиной" ветви \texttt{main}.
    На данном этапе история проекта разветвляется: ветвь \texttt{bugFix} содержит коммит \texttt{C2}, а ветвь \texttt{main} — коммит \texttt{C3}.
    \item \texttt{git merge bugFix}: Данная команда инициирует процесс слияния изменений из ветви \texttt{bugFix} в текущую активную ветвь (\texttt{main}).
    \begin{itemize}
        \item \texttt{git merge}: Команда для объединения истории коммитов из одной или нескольких ветвей в текущую ветвь.
        \item \texttt{bugFix}: Указывает на ветвь, содержимое которой должно быть интегрировано.
    \end{itemize}
    В результате операции слияния на правой панели изображения формируется новый коммит \texttt{C4}.
    Этот коммит является "коммитом слияния" (merge commit), обладающим двумя родительскими коммитами: \texttt{C2} (из ветви \texttt{bugFix}) и \texttt{C3} (из ветви \texttt{main}).
    Коммит \texttt{C4} символизирует точку, в которой две параллельные линии разработки были успешно объединены.
    В итоге, указатель \texttt{main*} перемещается на \texttt{C4}, что означает, что ветвь \texttt{main} теперь содержит все изменения, присутствующие как в своей собственной линии разработки, так и в ветви \texttt{bugFix}.
\end{itemize}
Механизмы ветвления и слияния в Git являются краеугольным камнем для организации эффективной командной разработки, позволяя параллельно вести работы над различными аспектами проекта и интегрировать их по мере готовности.

\subsection{Команды \texttt{git merge} и \texttt{git rebase}}\label{subsec:lgb-merge-and-rebase}
В Git существует два основных подхода к интеграции изменений из одной ветви в другую: слияние (merging) и перебазирование (rebasing).
Оба метода позволяют объединять истории разработки, но делают это по-разному, что приводит к формированию различных топологий графа коммитов.
Выбор между \texttt{merge} и \texttt{rebase} зависит от желаемой чистоты истории проекта и предпочтений команды.

\subsubsection{Слияние веток: Команда \texttt{git merge}}\label{subsubsec:git-merge}
Изображение \refFigure{git-branching/basics/c1t3.png} демонстрирует стандартный процесс слияния ветвей с использованием команды \texttt{git merge}.

\imageWithCaption{git-branching/basics/c1t3.png}{Процесс слияния веток с созданием коммита слияния}
\label{fig:lgb_merge}

На левой панели изображения представлена последовательность команд, выполненных в терминале:
\begin{itemize}
    \item \texttt{clear}: Очищает консоль для удобства восприятия.
    \item \texttt{git checkout -b bugFix}: Создает новую ветвь с именем \texttt{bugFix} и немедленно переключает на нее указатель HEAD. На правой панели видно, что ветвь \texttt{bugFix} теперь активна и указывает на тот же коммит, что и \texttt{main} (\texttt{C1} в начале ветвления).
    \item \texttt{git commit -m "c2"}: Создает новый коммит \texttt{C2} в ветви \texttt{bugFix}.
    Этот коммит является потомком \texttt{C1} и становится новой "головой" ветви \texttt{bugFix}.
    Ветвь \texttt{main} при этом остается на \texttt{C1}.
    \item \texttt{git checkout main}: Переключает активную ветвь обратно на \texttt{main}.
    Указатель HEAD теперь снова указывает на \texttt{main}.
    \item \texttt{git commit -m c3}: Создает новый коммит \texttt{C3} в ветви \texttt{main}.
    Коммит \texttt{C3} является потомком \texttt{C1} и становится новой "головой" ветви \texttt{main}.
    На данном этапе, история проекта разветвляется: \texttt{bugFix} содержит \texttt{C2}, а \texttt{main} содержит \texttt{C3}, причем \texttt{C2} и \texttt{C3} имеют общего предка \texttt{C1}.
    \item \texttt{git merge bugFix}: Данная команда инициирует процесс слияния.
    Git пытается интегрировать изменения из ветви \texttt{bugFix} в текущую активную ветвь (\texttt{main}). Поскольку истории обеих ветвей разошлись после общего предка \texttt{C1}, Git создает новый коммит.
\end{itemize}
На правой панели визуализации графа истории видно, что в результате \texttt{git merge bugFix} был создан новый коммит \texttt{C4}.
Этот коммит \texttt{C4} имеет двух родительских коммитов: \texttt{C2} (из ветви \texttt{bugFix}) и \texttt{C3} (из ветви \texttt{main}).
Такой коммит называется *коммитом слияния* (merge commit) и является явной точкой в истории, где две линии разработки были объединены.
Указатель \texttt{main*} теперь переместился на \texttt{C4}, отражая успешное объединение изменений.
Преимуществом данного метода является сохранение всей истории ветвей, что обеспечивает полную трассируемость изменений.

\subsubsection{Перебазирование веток: Команда \texttt{git rebase}}\label{subsubsec:git-rebase}
Изображение \refFigure{git-branching/basics/c1t4.png} демонстрирует альтернативный подход к интеграции изменений — перебазирование с использованием команды \texttt{git rebase}.

\imageWithCaption{git-branching/basics/c1t4.png}{Процесс перебазирования ветки для создания линейной истории}
\label{fig:lgb_rebase}

На левой панели изображения представлена последовательность команд, выполненных в терминале:
\begin{itemize}
    \item \texttt{clear}: Очищает консоль.
    \item \texttt{git checkout -b bugFix}: Создает новую ветвь \texttt{bugFix} и переключается на нее.
    \item \texttt{git commit -m c2}: Создает коммит \texttt{C2} в ветви \texttt{bugFix}.
    На данном этапе, на правой панели, коммит \texttt{C2} является "головой" ветви \texttt{bugFix}.
    \item \texttt{git checkout main}: Переключается обратно на ветвь \texttt{main}.
    \item \texttt{git commit -m c3}: Создает коммит \texttt{C3} в ветви \texttt{main}.
    Теперь, как и в примере со слиянием, история разветвляется: \texttt{bugFix} содержит \texttt{C2}, а \texttt{main} содержит \texttt{C3}, оба от \texttt{C1}.
    \item \texttt{git checkout bugFix}: Переключается обратно на ветвь \texttt{bugFix}, так как \texttt{rebase} обычно выполняется из той ветви, которую необходимо "перебазировать".
    \item \texttt{git rebase main}: Данная команда инициирует процесс перебазирования.
    Git выполняет следующие действия:
    \begin{enumerate}
        \item Временно сохраняет коммиты, уникальные для ветви \texttt{bugFix} (в данном случае, \texttt{C2}).
        \item Перемещает указатель HEAD ветви \texttt{bugFix} к базовому коммиту ветви \texttt{main} (т.е. к \texttt{C3}).
        \item Повторно применяет сохраненные коммиты (\texttt{C2}) поверх коммитов ветви \texttt{main}.
    \end{enumerate}
\end{itemize}
На правой панели визуализации графа истории видно, что после \texttt{git rebase main} коммит \texttt{C2} не исчезает, но вместо него появляется новый коммит \texttt{C2'}.
Этот коммит \texttt{C2'} является копией коммита \texttt{C2}, но его родительским коммитом теперь является \texttt{C3} (новый базовый коммит), а не \texttt{C1}.
Таким образом, история ветви \texttt{bugFix} "переписывается" так, что она начинается с последнего коммита ветви \texttt{main}, создавая линейную последовательность коммитов: \texttt{C0} $\rightarrow$ \texttt{C1} $\rightarrow$ \texttt{C3} $\rightarrow$ \texttt{C2'}.
Ветвь \texttt{bugFix*} теперь указывает на \texttt{C2'}.
Преимуществом \texttt{rebase} является создание "чистой" и линейной истории проекта без коммитов слияния, что может быть предпочтительнее для проектов с частыми интеграциями.
Однако следует помнить, что \texttt{rebase} изменяет историю коммитов, что может вызвать проблемы при работе с уже опубликованными ветвями.


\section{Продвинутые уровни: перемещение по истории}\label{sec:lgb-advanced-history-navigation}
В продвинутых уроках я познакомился с более сложными техниками, такими как выборочный перенос коммитов и отмена изменений.

\subsection{Команда \texttt{git cherry-pick}}\label{subsec:lgb-cherry-pick}
В дополнение к методам слияния (\texttt{merge}) и перебазирования (\texttt{rebase}), Git предоставляет более гранулированный механизм для интеграции изменений между ветвями — команду \texttt{git cherry-pick}.
Эта команда позволяет выборочно копировать отдельные коммиты из одной части истории проекта в другую, что особенно полезно, когда необходимо применить специфическое изменение без включения всей последовательности коммитов из исходной ветви.

\subsubsection{Функциональность и Применение \texttt{git cherry-pick}}\label{subsubsec:cherry-pick-functionality}
Изображение \refFigure{git-branching/basics/c5t3.png} демонстрирует практическое применение команды \texttt{git cherry-pick} в контексте сложной истории ветвления.

\imageWithCaption{git-branching/basics/c5t3.png}{Пример избирательного применения коммитов с помощью \texttt{git cherry-pick}}
\label{fig:lgb_cherry_pick}

На левой панели изображения представлена последовательность команд, выполненных в терминале, которые иллюстрируют сценарий использования \texttt{git cherry-pick}:
\begin{itemize}
    \item \texttt{clear}: Очищает консоль для обеспечения наглядности последующих операций.
    \item \texttt{git checkout one}: Переключает активную ветвь на \texttt{one}.
    На правой панели видно, что \texttt{one} указывает на коммит \texttt{C2'}.
    \item \texttt{git cherry-pick C4 C3 C2}: Это первая ключевая операция.
    \begin{itemize}
        \item \texttt{git cherry-pick}: Основная команда для применения выбранных коммитов.
        \item \texttt{C4 C3 C2}: Перечислены идентификаторы коммитов, которые требуется скопировать.
        В данном случае, это коммиты \texttt{C4}, \texttt{C3} и \texttt{C2} из исходной ветви (предположительно, \texttt{main} или ее предшественники).
        Git копирует изменения, внесенные этими коммитами, и применяет их как новые коммиты в текущей активной ветви (\texttt{one}), сохраняя при этом сообщения коммитов и их содержимое.
    \end{itemize}
    На правой панели графа истории видно, что после этой операции новые коммиты, содержащие изменения из \texttt{C4}, \texttt{C3} и \texttt{C2}, были созданы на ветви \texttt{one}.
    Эти новые коммиты могут иметь другие идентификаторы (например, \texttt{C4''}, \texttt{C3''}, \texttt{C2''} если бы они были явно показаны, или просто смещение указателя \texttt{one}), но их содержимое соответствует исходным коммитам.
    Визуализация показывает, что ветвь \texttt{one} теперь имеет историю, включающую эти скопированные изменения.
    \item \texttt{git checkout two}: Переключает активную ветвь на \texttt{two}.
    \item \texttt{git cherry-pick C5 C4' C3' C2'}: Вторая демонстрация использования \texttt{git cherry-pick}.
    Здесь коммиты \texttt{C5}, \texttt{C4'}, \texttt{C3'} и \texttt{C2'} копируются в ветвь \texttt{two}.
    Это демонстрирует гибкость команды: можно выборочно переносить изменения между различными ветвями, даже если они не являются прямыми предками или потомками друг друга.
    \item \texttt{git branch -f three C2}: Данная команда не относится напрямую к \texttt{cherry-pick}, но демонстрирует манипуляции с ветвями.
    Флаг \texttt{-f} (force) принудительно перемещает ветвь \texttt{three} на коммит \texttt{C2}, даже если это приводит к потере части истории ветви \texttt{three}, которая была после \texttt{C2}.
    \item \texttt{echo "level solved! type in 'levels' to access the next level"}: Служебное сообщение обучающей платформы, подтверждающее успешное выполнение задания.
\end{itemize}
На правой панели, после всех операций \texttt{cherry-pick}, ветви \texttt{main}, \texttt{one}, \texttt{two} и \texttt{three} расположены на своих финальных коммитах, отражая результаты избирательного копирования и манипуляций с ветвями.
В частности, ветвь \texttt{two*} (текущая активная) указывает на \texttt{C2''}, который является новым коммитом, содержащим изменения из ранее скопированных коммитов.

\texttt{git cherry-pick} является мощным инструментом для управления историей проекта, позволяющим разработчикам тщательно контролировать, какие изменения интегрируются в различные ветви, что особенно ценно для "хотфиксов" или для перемещения отдельных функциональностей без необходимости полного слияния ветвей.
Однако, как и \texttt{rebase}, \texttt{cherry-pick} создает новые коммиты, изменяя историю, что требует осторожности при работе с опубликованными ветвями.

\subsection{Команда \texttt{git reset} и \texttt{git revert}}\label{subsec:lgb-reset-and-revert}
В системе контроля версий Git предусмотрены различные механизмы для отмены изменений в истории проекта.
Два наиболее часто используемых метода — это \texttt{git reset} и \texttt{git revert}.
Несмотря на то, что обе команды служат цели отмены изменений, их принципы работы существенно различаются, что влияет на целостность и линейность истории коммитов.

\subsubsection{Откат Изменений: Команда \texttt{git reset}}\label{subsubsec:git-reset}
Изображение \refFigure{git-branching/basics/c2t4.png} демонстрирует применение команды \texttt{git reset} для модификации истории ветви.

\imageWithCaption{git-branching/basics/c2t4.png}{Применение \texttt{git reset} для отката указателя ветви и \texttt{git revert} для отмены коммита}
\label{fig:lgb_reset_revert}

На левой панели изображения представлена последовательность команд, выполненных в терминале:
\begin{itemize}
    \item \texttt{clear}: Очищает консоль для удобства восприятия.
    \item \texttt{git reset HEAD\^}: Данная команда является первой ключевой операцией по отмене изменений.
    \begin{itemize}
        \item \texttt{git reset}: Команда для перемещения указателя текущей ветви к определенному коммиту.
        Она может также изменять содержимое индекса и рабочей директории в зависимости от используемого режима (по умолчанию \texttt{--mixed}).
        \item \texttt{HEAD\^}: Это относительная ссылка, обозначающая родительский коммит для текущего положения HEAD. То есть, команда \texttt{git reset HEAD\^} перемещает указатель текущей ветви на один коммит назад по истории.
    \end{itemize}
    На правой панели графа истории Git, до выполнения этой команды, ветвь \texttt{main} и указатель \texttt{local} находятся на коммите \texttt{C2}.
    После выполнения \texttt{git reset HEAD\^}, указатель ветви \texttt{main} (и \texttt{local}) перемещается к коммиту \texttt{C1}.
    Коммит \texttt{C2} и его потомок \texttt{C2'} (если он был ранее на \texttt{main}) теперь становятся "отрезанными" от ветви \texttt{main}, но могут оставаться доступными через \texttt{reflog} или другие ветви (как \texttt{pushed} на рисунке, которая осталась на \texttt{C2\'}).
    Важно отметить, что \texttt{git reset} *переписывает* историю, удаляя коммиты из текущей ветви (делая их недостижимыми для обычных операций, если нет других ссылок на них), что может быть проблематично в общих репозиториях.
    \item \texttt{git checkout pushed}: Переключает активную ветвь на \texttt{pushed}.
    На правой панели видно, что \texttt{pushed*} теперь является активной ветвью и указывает на коммит \texttt{C2'}.
    Это действие не отменяет изменений, а лишь меняет контекст работы.
\end{itemize}
Таким образом, \texttt{git reset} используется для перемещения ветви на более ранний коммит, эффективно "отменяя" все последующие коммиты в этой ветви.
Этот метод рекомендуется использовать с осторожностью, особенно на опубликованных ветвях, поскольку он изменяет историю.

\subsubsection{Создание Отменяющих Коммитов: Команда \texttt{git revert}}\label{subsubsec:git-revert}
Продолжая анализ изображения \refFigure{git-branching/basics/c2t4.png}, рассмотрим применение команды \texttt{git revert}.

\imageWithCaption{git-branching/basics/c2t4.png}{Применение \texttt{git reset} для отката указателя ветви и \texttt{git revert} для отмены коммита}
\label{fig:lgb_reset_revert_continued}

На левой панели изображения, после команды \texttt{git checkout pushed}, выполняется следующая операция:
\begin{itemize}
    \item \texttt{git revert HEAD}: Эта команда является вторым основным методом отмены изменений.
    \begin{itemize}
        \item \texttt{git revert}: Команда, которая создает *новый коммит*, содержащий изменения, противоположные изменениям указанного коммита.
        Это означает, что \texttt{git revert} не удаляет коммиты из истории, а добавляет новый коммит, который "отменяет" эффект предыдущего.
        \item \texttt{HEAD}: В данном случае, \texttt{HEAD} указывает на коммит \texttt{C2'}.
        Таким образом, \texttt{git revert HEAD} отменяет изменения, внесенные в коммите \texttt{C2'}.
    \end{itemize}
    На правой панели графа истории после выполнения этой команды, на ветви \texttt{pushed} (которая была активной), появился новый коммит.
    Хотя на данном изображении этот новый коммит не имеет явного обозначения (как \texttt{C3} или \texttt{C2\'\'}), его появление в истории ветви \texttt{pushed} является результатом \texttt{git revert HEAD}. Суть в том, что этот новый коммит содержит изменения, которые "откатывают" проект к состоянию, предшествующему \texttt{C2\'}, но при этом сам коммит \texttt{C2\'} остается в истории.
\end{itemize}
Ключевое отличие \texttt{git revert} от \texttt{git reset} заключается в том, что \texttt{git revert} не переписывает историю, а добавляет новый коммит, что делает его безопасным для использования на ветвях, которые уже были опубликованы и доступны другим разработчикам.
Это сохраняет целостность истории проекта, что является критически важным в сценариях совместной разработки.


\section{Работа с удаленными репозиториями}\label{sec:lgb-remote-repositories}
В контексте распределенных систем контроля версий, таких как Git, работа с удаленными репозиториями является краеугольным камнем для совместной разработки и централизованного хранения кодовой базы.
Данный раздел посвящен основным операциям взаимодействия с удаленными серверами, включая клонирование, отправку и получение изменений.

\subsection{Инициализация Рабочей Копии: Команда \texttt{git clone}}\label{subsec:git-clone}
Изображение \refFigure{git-branching/remotes/c1t1.png} иллюстрирует процесс клонирования удаленного репозитория, который является первым шагом при начале работы с существующим проектом.

\imageWithCaption{git-branching/remotes/c1t1.png}{Процесс клонирования удаленного репозитория}
\label{fig:lgb_clone}

На левой панели изображения представлены команды, выполненные в терминале:
\begin{itemize}
    \item \texttt{level remote1}, \texttt{hint}, \texttt{delay 2000}, \texttt{show goal}: Эти команды относятся к обучающей среде и служат для настройки уровня и предоставления инструкций.
    Подсказка "Простой git clone!" прямо указывает на основную задачу.
    \item \texttt{git clone}: Данная команда является основной для создания локальной копии (клона) удаленного репозитория.
    В контексте обучающей среды, возможно, не указывается полный URL удаленного репозитория, так как он подразумевается.
    В реальной практике команда выглядит как \texttt{git clone <URL\_репозитория>}, например, \texttt{git clone https://github.com/user/repo.git}.
\end{itemize}
На правой панели изображения представлены два графа коммитов, символизирующие удаленный (\texttt{o/main}) и локальный (\texttt{main}) репозитории.
Изначально удаленный репозиторий (\texttt{o/main}) содержит коммиты \texttt{C0} и \texttt{C1}.
После выполнения команды \texttt{git clone} создается локальная копия этого репозитория.
На правой стороне видно, что локальная ветвь \texttt{main*} (активная ветвь) создана и указывает на \texttt{C1}.
Одновременно создается удаленная отслеживающая ветвь \texttt{o/main} (или \texttt{origin/main}), которая также указывает на \texttt{C1}.
Это означает, что локальный репозиторий содержит полную историю проекта из удаленного репозитория на момент клонирования.
Сообщение в консоли "local branch "main" set to track remote branch "o/main\"" подтверждает, что локальная ветвь \texttt{main} была автоматически настроена для отслеживания удаленной ветви \texttt{o/main}, что упрощает последующие операции \texttt{pull} и \texttt{push}.

\subsection{Отправка Изменений: Команда \texttt{git push}}\label{subsec:git-push}
Изображение \refFigure{git-branching/remotes/c2t5.png} демонстрирует механизм отправки локальных изменений на удаленный репозиторий с использованием команды \texttt{git push}.

\imageWithCaption{git-branching/remotes/c2t5.png}{Пример отправки изменений на удаленный сервер с помощью \texttt{git push}}
\label{fig:lgb_push}

На левой панели изображения представлены команды, выполненные в терминале:
\begin{itemize}
    \item \texttt{clear}: Очищает консоль.
    \item \texttt{git push origin foo:main}: Эта команда является первой демонстрацией \texttt{git push} в расширенном формате.
    \begin{itemize}
        \item \texttt{git push}: Основная команда для отправки локальных коммитов в удаленный репозиторий.
        \item \texttt{origin}: Это стандартное имя для удаленного репозитория, с которого был клонирован текущий локальный репозиторий (или который был добавлен вручную).
        \item \texttt{foo:main}: Данный синтаксис \texttt{[локальная\_ветвь]:[удаленная\_ветвь]} указывает Git, что необходимо взять содержимое локальной ветви \texttt{foo} и отправить его в удаленную ветвь \texttt{main} на сервере \texttt{origin}.
        На правой панели видно, что до этой команды, вероятно, \texttt{foo} была на \texttt{C4}, а \texttt{main} на \texttt{C6}.
        В результате \texttt{git push origin foo:main}, удаленная ветвь \texttt{o/main} перемещается на коммит \texttt{C4}, отражая изменения из локальной \texttt{foo}.
    \end{itemize}
    \item \texttt{git push origin main:foo}: Эта команда является второй демонстрацией \texttt{git push}, но с обратным назначением ветвей.
    \begin{itemize}
        \item \texttt{main:foo}: В данном случае, локальная ветвь \texttt{main} (которая указывает на \texttt{C6}) отправляется в удаленную ветвь \texttt{foo} на сервере \texttt{origin}.
    \end{itemize}
    На правой панели графа истории после выполнения этой команды, удаленная ветвь \texttt{o/foo} (обозначенная как \texttt{o/foo}) перемещается на коммит \texttt{C5}.
    Это демонстрирует, что \texttt{git push} позволяет не только обновлять удаленные ветви, но и создавать новые удаленные ветви или даже обновлять существующие удаленные ветви с содержимым из локальных ветвей, имеющих другое имя.
    Здесь, локальная ветвь \texttt{main} (указывающая на \texttt{C6}) отправила свои изменения в удаленную \texttt{o/foo}, которая теперь указывает на \texttt{C5}.
    Визуализация показывает, что удаленные ветви (\texttt{o/main} и \texttt{o/foo}) теперь отражают изменения, "запушенные" из локального репозитория.
\end{itemize}
Команда \texttt{git push} является критически важной для синхронизации локально внесенных изменений с удаленным репозиторием, делая их доступными для других участников проекта.
Ее гибкий синтаксис \texttt{[локальная\_ветвь]:[удаленная\_ветвь]} позволяет точно контролировать, какие локальные ветви и как должны быть представлены на удаленном сервере.


\chapterConclusionSection{git_branching_chapter_title}
В этой главе я задокументировал прохождение интерактивного курса Learn Git Branching.
Визуализация процесса помогла мне глубоко понять механику работы веток в Git.
Я освоил как базовые операции (\texttt{commit}, \texttt{branch}, \texttt{merge}), так и более сложные (\texttt{rebase}, \texttt{cherry-pick}).
